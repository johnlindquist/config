#!/usr/bin/env bash
#
# Global pre-commit hook
# 1. Local project hook (.git/hooks/pre-commit) - runs FIRST for fast failures
# 2. ANTI-SLOP BOT 2000 - Claude-powered code quality check
# 3. Beads integration - Sync issue tracking data
#
# Skip with: git commit --no-verify (or -n)
# Disable slop check: ANTI_SLOP=0 git commit -m "message"
#

set -euo pipefail

# Ensure we're at the repository root
cd "$(git rev-parse --show-toplevel)" || exit 1

# ============================================================
# PER-PROJECT DISABLE CHECK
# ============================================================

# Create .git/hooks/anti-slop-disable to skip in this repo
if [[ -f "$(git rev-parse --git-dir 2>/dev/null)/hooks/anti-slop-disable" ]]; then
    exit 0
fi

# ============================================================
# SMART PROJECT DETECTION
# ============================================================
# Skip anti-slop for "non-project" repos (pure docs, notes, configs)
# Force enable with: ANTI_SLOP_FORCE=1 git commit

is_real_project() {
    # Project markers that indicate this is a "real" code project
    local PROJECT_MARKERS=(
        "package.json"
        "package-lock.json"
        "yarn.lock"
        "pnpm-lock.yaml"
        "bun.lockb"
        "Cargo.toml"
        "Cargo.lock"
        "go.mod"
        "go.sum"
        "pyproject.toml"
        "setup.py"
        "requirements.txt"
        "Pipfile"
        "poetry.lock"
        "composer.json"
        "Gemfile"
        "Gemfile.lock"
        "pom.xml"
        "build.gradle"
        "build.gradle.kts"
        "CMakeLists.txt"
        "Makefile"
        "meson.build"
        "setup.cfg"
        ".beads"
        "Dockerfile"
        "docker-compose.yml"
        "docker-compose.yaml"
        ".github/workflows"
    )

    for marker in "${PROJECT_MARKERS[@]}"; do
        if [[ -e "$marker" ]]; then
            return 0  # Is a real project
        fi
    done

    return 1  # Not a real project
}

has_code_files_in_repo() {
    # Check if repo contains ANY code files (not just staged)
    local CODE_PATTERN='.*\.(js|jsx|ts|tsx|py|go|rs|java|kt|swift|c|cpp|h|hpp|rb|php|cs|scala|sh|bash|zsh|vue|svelte|astro)$'
    if git ls-files | grep -qE "$CODE_PATTERN" 2>/dev/null; then
        return 0  # Has code files
    fi
    return 1  # No code files
}

# Smart skip logic (can be forced with ANTI_SLOP_FORCE=1)
if [[ "${ANTI_SLOP_FORCE:-0}" != "1" ]]; then
    if ! is_real_project && ! has_code_files_in_repo; then
        # Completely skip for non-project repos
        exit 0
    fi
fi

# ============================================================
# LOCAL PROJECT HOOK (runs first for fast failures)
# ============================================================

LOCAL_HOOK="$(git rev-parse --git-dir 2>/dev/null)/hooks/pre-commit"
if [[ -x "$LOCAL_HOOK" ]]; then
    echo -e "\033[0;36mðŸ”— Running local pre-commit hook...\033[0m"
    if ! "$LOCAL_HOOK" "$@"; then
        echo -e "\033[0;31mâŒ Local pre-commit hook failed\033[0m"
        exit 1
    fi
fi

# ============================================================
# ANTI-SLOP BOT 2000
# ============================================================

# Configuration
TIMEOUT_SECONDS="${ANTI_SLOP_TIMEOUT:-90}"
MODEL="${ANTI_SLOP_MODEL:-opus}"
MAX_DIFF_LINES="${ANTI_SLOP_MAX_LINES:-2000}"
ENABLED="${ANTI_SLOP:-1}"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# ASCII art banner
print_banner() {
    echo -e "${MAGENTA}"
    echo '    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—'
    echo '    â•‘     ðŸ¤– ANTI-SLOP BOT 2000 ðŸ¤–              â•‘'
    echo '    â•‘     Powered by Claude Opus                â•‘'
    echo '    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
    echo -e "${NC}"
}

run_anti_slop() {
    # Check if anti-slop is disabled
    if [[ "$ENABLED" == "0" ]]; then
        echo -e "${YELLOW}â­ï¸  Anti-Slop Bot 2000 disabled (ANTI_SLOP=0)${NC}"
        return 0
    fi

    # Check if claude is available
    if ! command -v claude &> /dev/null; then
        echo -e "${YELLOW}âš ï¸  Claude CLI not found, skipping anti-slop check${NC}"
        return 0
    fi

    # Get staged files (code files only)
    CODE_EXTENSIONS='(js|jsx|ts|tsx|py|go|rs|java|kt|swift|c|cpp|h|hpp|rb|php|cs|scala|sh|bash|zsh|vue|svelte|astro|md|json|yaml|yml|toml)'
    STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACMR 2>/dev/null | grep -E "\.${CODE_EXTENSIONS}$" || true)

    # Exit early if no code files staged
    if [[ -z "$STAGED_FILES" ]]; then
        echo -e "${GREEN}âœ¨ No code files staged, skipping anti-slop check${NC}"
        return 0
    fi

    FILE_COUNT=$(echo "$STAGED_FILES" | wc -l | tr -d ' ')

    # Get the diff
    DIFF=$(git diff --cached -U5 2>/dev/null || true)

    # Check diff size
    DIFF_LINES=$(echo "$DIFF" | wc -l | tr -d ' ')
    if [[ "$DIFF_LINES" -gt "$MAX_DIFF_LINES" ]]; then
        echo -e "${YELLOW}âš ï¸  Diff too large (${DIFF_LINES} lines > ${MAX_DIFF_LINES} max)${NC}"
        echo -e "${YELLOW}   Set ANTI_SLOP_MAX_LINES to increase limit, or use --no-verify${NC}"
        return 0
    fi

    print_banner
    echo -e "${CYAN}ðŸ“‹ Reviewing ${FILE_COUNT} file(s)...${NC}"
    echo -e "${CYAN}ðŸ“ Diff size: ${DIFF_LINES} lines${NC}"
    echo ""

    # The Anti-Slop Bot 2000 system prompt
    SYSTEM_PROMPT='You are the ANTI-SLOP BOT 2000, an elite code quality guardian.

Your mission: Detect and REJECT low-quality "slop" code before it pollutes the codebase.

## What is "Slop"?
- Security vulnerabilities (SQL injection, XSS, command injection, hardcoded secrets)
- Obvious bugs (null derefs, off-by-one errors, race conditions, unclosed resources)
- Dead code being added (unused imports, unreachable code, commented-out code blocks)
- Console.log/print debugging left in production code
- TODO/FIXME/HACK comments in new code (should be in issue tracker)
- Duplicated code that should be abstracted
- Magic numbers/strings without explanation
- Empty catch blocks that swallow errors
- Infinite loops or obvious performance disasters
- Sensitive data exposure (API keys, passwords, tokens in code)

## What is NOT Slop (ignore these):
- Style preferences (you are not a linter)
- Missing documentation (unless critical public API)
- Test coverage (separate concern)
- Architecture decisions (not your call)
- Existing code that was not changed

## Output Format
You MUST respond with ONLY valid JSON, no markdown, no explanation:

If issues found:
{
  "status": "REJECTED",
  "issues": [
    {
      "severity": "critical|high|medium",
      "file": "path/to/file.ts",
      "line": 42,
      "type": "security|bug|dead-code|debug|todo|duplication|magic-value|error-handling|performance|secrets",
      "message": "Brief description of the issue",
      "suggestion": "How to fix it"
    }
  ],
  "summary": "One-line summary of why this commit was rejected"
}

If no issues:
{
  "status": "APPROVED",
  "message": "Brief positive message about the code quality"
}

CRITICAL RULES:
1. ONLY analyze lines starting with + (additions) in the diff
2. Do NOT invent issues - only report what you can see in the diff
3. Do NOT flag style issues - focus on real problems
4. Be strict but fair - reject obvious slop, approve clean code
5. "critical" severity = security vulnerabilities or data exposure
6. "high" severity = bugs that will cause runtime failures
7. "medium" severity = code smell that should be fixed but wont crash'

    # JSON Schema for structured output
    JSON_SCHEMA='{
  "type": "object",
  "properties": {
    "status": {
      "type": "string",
      "enum": ["APPROVED", "REJECTED"]
    },
    "message": {
      "type": "string",
      "description": "Positive message when approved"
    },
    "summary": {
      "type": "string",
      "description": "One-line summary when rejected"
    },
    "issues": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "severity": {
            "type": "string",
            "enum": ["critical", "high", "medium"]
          },
          "file": { "type": "string" },
          "line": { "type": "integer" },
          "type": {
            "type": "string",
            "enum": ["security", "bug", "dead-code", "debug", "todo", "duplication", "magic-value", "error-handling", "performance", "secrets"]
          },
          "message": { "type": "string" },
          "suggestion": { "type": "string" }
        },
        "required": ["severity", "file", "type", "message", "suggestion"]
      }
    }
  },
  "required": ["status"]
}'

    # Get the project directory for context
    PROJECT_DIR=$(pwd)
    PROJECT_NAME=$(basename "$PROJECT_DIR")

    # Run Claude in print mode
    PROMPT="Review this git diff and determine if it should be committed or rejected.

PROJECT: ${PROJECT_NAME}
DIRECTORY: ${PROJECT_DIR}

FILES CHANGED:
${STAGED_FILES}

GIT DIFF:
\`\`\`diff
${DIFF}
\`\`\`

Analyze the additions (lines starting with +) and respond with JSON only."

    # Create temp file for output
    TEMP_OUTPUT=$(mktemp)
    trap "rm -f $TEMP_OUTPUT" RETURN

    echo -e "${CYAN}ðŸ” Analyzing with Claude ${MODEL}...${NC}"

    # Run claude with timeout and JSON schema for structured output
    if timeout "${TIMEOUT_SECONDS}s" claude -p \
        --setting-sources "" \
        --mcp-config '{"mcpServers": {}}' \
        --strict-mcp-config \
        --add-dir "$PROJECT_DIR" \
        --model "$MODEL" \
        --system-prompt "$SYSTEM_PROMPT" \
        --output-format json \
        --json-schema "$JSON_SCHEMA" \
        "$PROMPT" > "$TEMP_OUTPUT" 2>&1; then

        # Parse the result - with --json-schema, Claude returns structured data in 'structured_output'
        RESULT=$(cat "$TEMP_OUTPUT")

        # Extract the structured_output field from Claude's response wrapper
        if echo "$RESULT" | jq -e '.structured_output' &>/dev/null; then
            INNER_JSON=$(echo "$RESULT" | jq '.structured_output' 2>/dev/null)
        elif echo "$RESULT" | jq -e '.result' &>/dev/null; then
            INNER_JSON=$(echo "$RESULT" | jq -r '.result' 2>/dev/null)
        else
            INNER_JSON="$RESULT"
        fi

        # Parse the status
        STATUS=$(echo "$INNER_JSON" | jq -r '.status // "UNKNOWN"' 2>/dev/null || echo "UNKNOWN")

        if [[ "$STATUS" == "APPROVED" ]]; then
            MESSAGE=$(echo "$INNER_JSON" | jq -r '.message // "Code looks good!"' 2>/dev/null)
            echo ""
            echo -e "${GREEN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
            echo -e "${GREEN}â•‘  âœ… APPROVED - Code passed quality check  â•‘${NC}"
            echo -e "${GREEN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
            echo ""
            echo -e "${GREEN}${MESSAGE}${NC}"
            echo ""
            return 0

        elif [[ "$STATUS" == "REJECTED" ]]; then
            echo ""
            echo -e "${RED}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
            echo -e "${RED}â•‘  ðŸš« REJECTED - Slop detected!             â•‘${NC}"
            echo -e "${RED}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
            echo ""

            SUMMARY=$(echo "$INNER_JSON" | jq -r '.summary // "Quality issues found"' 2>/dev/null)
            echo -e "${RED}${BOLD}Summary:${NC} ${SUMMARY}"
            echo ""

            # Print each issue
            echo -e "${BOLD}Issues:${NC}"
            echo "$INNER_JSON" | jq -r '.issues[]? | "  [\(.severity | ascii_upcase)] \(.file):\(.line // "?") - \(.type)\n    â†’ \(.message)\n    ðŸ’¡ \(.suggestion)\n"' 2>/dev/null || echo "  (Could not parse issues)"

            echo ""
            echo -e "${YELLOW}Fix the issues above and try again.${NC}"
            echo -e "${YELLOW}Use 'git commit --no-verify' to bypass (not recommended).${NC}"
            echo ""
            return 1
        else
            # Unknown status - log and continue
            echo -e "${YELLOW}âš ï¸  Could not parse Claude response, allowing commit${NC}"
            cat "$TEMP_OUTPUT"
            return 0
        fi
    else
        EXIT_CODE=$?
        if [[ $EXIT_CODE -eq 124 ]]; then
            echo -e "${YELLOW}â±ï¸  Anti-Slop Bot timed out after ${TIMEOUT_SECONDS}s${NC}"
            echo -e "${YELLOW}   Set ANTI_SLOP_TIMEOUT to increase, or use --no-verify${NC}"
        else
            echo -e "${YELLOW}âš ï¸  Claude exited with code ${EXIT_CODE}${NC}"
            echo -e "${YELLOW}   Output: $(cat "$TEMP_OUTPUT" 2>/dev/null || echo 'none')${NC}"
        fi
        # Allow commit on timeout/error to not block development
        echo -e "${YELLOW}   Allowing commit to proceed...${NC}"
        return 0
    fi
}

# Run anti-slop check
if ! run_anti_slop; then
    exit 1
fi

# ============================================================
# BEADS INTEGRATION
# ============================================================

if [ -d .beads ]; then
    if command -v bd >/dev/null 2>&1; then
        # Flush pending changes to JSONL
        if ! bd sync --flush-only >/dev/null 2>&1; then
            echo "Error: Failed to flush bd changes to JSONL" >&2
            echo "Run 'bd sync --flush-only' manually to diagnose" >&2
            exit 1
        fi
        # Stage JSONL files
        for f in .beads/beads.jsonl .beads/issues.jsonl .beads/deletions.jsonl; do
            [ -f "$f" ] && git add "$f" 2>/dev/null || true
        done
    fi
fi

# ============================================================
# CHAIN TO .LOCAL OVERRIDE (optional manual hooks)
# ============================================================

LOCAL_OVERRIDE="$(git rev-parse --git-dir 2>/dev/null)/hooks/pre-commit.local"
[ -x "$LOCAL_OVERRIDE" ] && exec "$LOCAL_OVERRIDE" "$@"

exit 0
